/*!
 * @pluginjs/events v0.7.16 (https://pluginjs.com)
 * Copyright 2019 Creation Studio Limited
 * Released under the GPL-3.0 License.
 */
import { isString, isFunction } from '@pluginjs/is';
import { curryWith } from '@pluginjs/utils';
import Emitter from '@pluginjs/emitter';

class EventEmitter extends Emitter {
  constructor(element) {
    super();
    this.element = element;
    this.element._eventEmitter = this;
  }

  static getEventEmitter(element) {
    if (!element._eventEmitter) {
      element._eventEmitter = new this(element);
    }

    return element._eventEmitter;
  }

}

/* eslint-disable no-undefined, no-undef */

var supportEventListener = element => {
  return typeof element === 'object' && 'addEventListener' in element;
};

var trigger = function trigger(event) {
  for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    args[_key - 1] = arguments[_key];
  }

  var element = args[args.length - 1];

  if (!supportEventListener(element)) {
    return;
  }

  if (event instanceof window.Event) {
    element.dispatchEvent(event);
    return;
  }

  var data = args.length > 1 ? args.slice(0, args.length - 1) : null;
  var {
    eventName,
    namespace
  } = EventEmitter.parseEvent(event);
  var cusEvent = new CustomEvent(eventName, {
    cancelable: true,
    bubbles: true,
    detail: data
  });

  if (namespace) {
    cusEvent.namespace = namespace;
  }

  element.dispatchEvent(cusEvent);
};

var getDelegator = (event, selector, callback, element) => {
  return (e, args) => {
    var target = e.target;
    var currentTarget = e.currentTarget || element;
    var applyArgs = args ? [e].concat(args) : [e];
    var result;

    if (isString(selector)) {
      while (target && target !== currentTarget) {
        if (target.matches(selector)) {
          result = callback.apply(target, applyArgs);
        }

        target = target.parentNode;
      }
    } else {
      result = callback.apply(currentTarget, applyArgs);
    }

    if (result === false) {
      e.preventDefault();
      e.stopPropagation();
    }
  };
};

var dispatch = e => {
  var eventName = typeof e.namespace === 'undefined' ? e.type : "".concat(e.type, ".").concat(e.namespace);
  var emitter = EventEmitter.getEventEmitter(e.currentTarget);

  if (e.detail) {
    emitter.emit(eventName, e, e.detail);
  } else {
    emitter.emit(eventName, e);
  }
};

var bind = (event, selector, callback, element, once) => {
  var emitter = EventEmitter.getEventEmitter(element);
  var {
    eventName
  } = EventEmitter.parseEvent(event);

  if (!emitter.hasListeners(event)) {
    element.addEventListener(eventName, dispatch, false);
  }

  var delegator = getDelegator(event, selector, callback, element);
  callback._delegator = delegator;

  if (once) {
    emitter.once(event, delegator);
  } else {
    emitter.on(event, delegator);
  }
};

var removeEvent = curryWith((events, selector, callback, element) => {
  var eventArr = events.split(' ');

  if (eventArr.length > 1) {
    eventArr.forEach(e => {
      removeEvent(e, selector, callback, element);
    });
  } else {
    if (!isString(selector) && !isFunction(callback)) {
      element = callback;
      callback = selector;
      selector = undefined;
    }

    if (!isFunction(callback)) {
      element = callback;
      callback = undefined;
    }

    var event = events;
    var emitter = EventEmitter.getEventEmitter(element);
    var {
      eventName
    } = EventEmitter.parseEvent(event);

    if (emitter.hasListeners(event)) {
      if (emitter.getListeners(event).length === 0) {
        element.removeEventListener(eventName, dispatch);
      }

      if (typeof callback === 'undefined') {
        emitter.off(event);
      } else {
        emitter.off(event, callback._delegator);
      }
    }
  }

  return element;
}, supportEventListener);
var bindEvent = curryWith((events, selector, callback, element) => {
  var eventArr = events.split(' ');
  var selectorArr = isString(selector) ? selector.split(',') : null;

  switch (true) {
    case Boolean(eventArr.length > 1):
      {
        eventArr.forEach(e => {
          bindEvent(e, selector, callback, element);
        });
        break;
      }

    case Boolean(selectorArr && selectorArr.length > 1):
      {
        selectorArr.forEach(s => {
          bindEvent(events, s.trim(), callback, element);
        });
        break;
      }

    default:
      {
        if (!isString(selector) && !isFunction(callback)) {
          element = callback;
          callback = selector;
          selector = undefined;
        }

        bind(events, selector, callback, element);
        break;
      }
  }

  return element;
}, supportEventListener);
var bindEventOnce = curryWith((events, selector, callback, element) => {
  var eventArr = events.split(' ');
  var selectorArr = isString(selector) ? selector.split(',') : null;

  switch (true) {
    case Boolean(eventArr.length > 1):
      {
        eventArr.forEach(e => {
          bindEventOnce(e, selector, callback, element);
        });
        break;
      }

    case Boolean(selectorArr && selectorArr.length > 1):
      {
        selectorArr.forEach(s => {
          bindEventOnce(events, s.trim(), callback, element);
        });
        break;
      }

    default:
      {
        if (!isString(selector) && !isFunction(callback)) {
          element = callback;
          callback = selector;
          selector = undefined;
        }

        var recursiveFunction = e => {
          removeEvent(eventArr[0], selector, recursiveFunction, element);
          return callback(e);
        };

        bind(eventArr[0], selector, recursiveFunction, element, true);
        break;
      }
  }

  return element;
}, supportEventListener);
var on = bindEvent;
var off = removeEvent;
var once = bindEventOnce;
var getEventEmitter = element => EventEmitter.getEventEmitter(element);

export { bindEvent, bindEventOnce, getEventEmitter, off, on, once, removeEvent, trigger };
