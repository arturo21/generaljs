/*!
 * @pluginjs/emitter v0.7.15 (https://pluginjs.com)
 * Copyright 2019 Creation Studio Limited
 * Released under the GPL-3.0 License.
 */
'use strict';

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var SimpleEmitter = _interopDefault(require('@pluginjs/simple-emitter'));

class Emitter extends SimpleEmitter {
  constructor() {
    super();
    this.namespaces = {};
  }

  addListener(event, listener) {
    var context = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
    var one = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
    this.ensureListener(listener);
    var {
      eventName,
      namespace
    } = this.constructor.parseEvent(event);

    if (!eventName) {
      throw new Error('Event should not be null.');
    }

    if (!this.listeners[eventName]) {
      this.listeners[eventName] = {};
    }

    if (!namespace) {
      this.addToEvent(eventName, context, listener, one);
    } else {
      this.addToEventWithNamespace(eventName, namespace, context, listener, one);
      this.addToNamespace(eventName, namespace);
    }

    return this;
  }

  removeListener(event, listener) {
    if (this.hasListeners(event)) {
      var {
        eventName,
        namespace
      } = this.constructor.parseEvent(event);

      switch (true) {
        case Boolean(!namespace && eventName):
          {
            this.filterListeners(eventName, '*', listener);
            break;
          }

        case Boolean(!eventName && namespace):
          {
            var events = this.namespaces[namespace];

            for (var i = 0; i < events.length; i++) {
              this.filterListeners(events[i], namespace, listener);
            }

            for (var _i = 0; _i < events.length; _i++) {
              if (!Object.prototype.hasOwnProperty.call(this.listeners[events[_i]], namespace)) {
                this.removeEventInNamespaces(events[_i], namespace);
              }
            }

            break;
          }

        case Boolean(eventName && namespace):
          {
            var callback = this.removeEventInNamespaces(eventName, namespace);
            this.filterListeners(eventName, namespace, listener, callback);
            break;
          }

        default:
          {
            break;
          }
      }
    }

    return this;
  }

  removeAllListeners(event) {
    if (this.hasListeners(event)) {
      var {
        eventName,
        namespace
      } = this.constructor.parseEvent(event);

      switch (true) {
        case Boolean(!namespace && eventName):
          {
            var keys = Object.keys(this.listeners[eventName]);
            keys.forEach(key => {
              if (Object.prototype.hasOwnProperty.call(this.namespaces, key)) {
                this.removeEventInNamespaces(eventName, key);
              }
            });
            delete this.listeners[eventName];
            break;
          }

        case Boolean(!eventName && namespace):
          {
            var events = this.namespaces[namespace];

            for (var i = 0; i < events.length; i++) {
              delete this.listeners[events[i]][namespace];
            }

            delete this.namespaces[namespace];
            break;
          }

        case Boolean(eventName && namespace):
          {
            this.removeEventInNamespaces(eventName, namespace);
            delete this.listeners[eventName][namespace];
            break;
          }

        default:
          break;
      }
    }

    return this;
  }

  hasListeners(event) {
    var {
      eventName,
      namespace
    } = this.constructor.parseEvent(event);

    if (!namespace && eventName) {
      if (!this.listeners[eventName] || Object.keys(this.listeners[eventName]).length === 0) {
        return false;
      }

      return true;
    }

    if (!eventName && namespace) {
      if (!this.namespaces[namespace] || Object.keys(this.namespaces[namespace]).length === 0) {
        return false;
      }

      return true;
    }

    if (eventName && namespace) {
      if (!this.listeners[eventName] || !this.listeners[eventName][namespace] || this.listeners[eventName][namespace].length === 0) {
        return false;
      }

      return true;
    }

    return false;
  }

  getListeners(event) {
    if (this.hasListeners(event)) {
      var {
        eventName,
        namespace
      } = this.constructor.parseEvent(event);
      var sortedListeners = [];

      switch (true) {
        case Boolean(!namespace && eventName):
          {
            var keys = Object.keys(this.listeners[eventName]);
            keys.forEach(key => {
              for (var i = 0; i < this.listeners[eventName][key].length; i++) {
                sortedListeners = sortedListeners.concat(this.listeners[eventName][key][i]);
              }
            });
            return sortedListeners;
          }

        case Boolean(!eventName && namespace):
          {
            var events = this.namespaces[namespace];

            for (var i = 0; i < events.length; i++) {
              for (var j = 0; j < this.listeners[events[i]][namespace].length; j++) {
                sortedListeners = sortedListeners.concat(this.listeners[events[i]][namespace][j]);
              }
            }

            return sortedListeners;
          }

        case Boolean(eventName && namespace):
          {
            var namespaces = this.listeners[eventName];

            if (Object.prototype.hasOwnProperty.call(namespaces, namespace)) {
              for (var _i2 = 0; _i2 < namespaces[namespace].length; _i2++) {
                sortedListeners = sortedListeners.concat(namespaces[namespace][_i2]);
              }

              return sortedListeners;
            }

            return sortedListeners;
          }

        default:
          break;
      }
    }

    return [];
  }

  filterListeners(eventName, namespace, listener, callback) {
    var listeners = this.listeners[eventName];

    if (typeof listeners[namespace] !== 'undefined') {
      listeners[namespace] = listeners[namespace].filter(value => value.listener !== listener);

      if (listeners[namespace].length === 0) {
        if (callback) {
          callback();
        }

        delete listeners[namespace];
      }
    }

    this.listeners[eventName] = listeners;
  }

  removeEventInNamespaces(event, namespace) {
    var i = this.namespaces[namespace].length;

    while (i--) {
      if (this.namespaces[namespace][i] === event) {
        this.namespaces[namespace].splice(i, 1);
      }
    }
  }

  addToEvent(eventName, context, listener) {
    var one = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;

    if (!this.listeners[eventName]['*']) {
      this.listeners[eventName]['*'] = [];
    }

    this.listeners[eventName]['*'].push({
      context,
      listener,
      one
    });
  }

  addToEventWithNamespace(eventName, namespace, context, listener) {
    var one = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;

    if (!this.listeners[eventName][namespace]) {
      this.listeners[eventName][namespace] = [];
    }

    this.listeners[eventName][namespace].push({
      context,
      listener,
      one
    });
  }

  addToNamespace(eventName, namespace) {
    if (!this.namespaces[namespace]) {
      this.namespaces[namespace] = [];
    }

    if (!this.checkNamespace(eventName, namespace)) {
      this.namespaces[namespace].push(eventName);
    }
  }

  checkNamespace(eventName, namespace) {
    for (var i = 0; i < this.namespaces[namespace].length; i++) {
      if (this.namespaces[namespace][i] === eventName) {
        return true;
      }
    }

    return false;
  }

  static parseEvent(event) {
    var delimiter = '.';

    if (typeof event !== 'string') {
      event = event.toString();
    }

    if (event.indexOf(delimiter) === -1) {
      var _eventName = event.trim().length > 1 ? event : null;

      var _namespace = null;
      return {
        eventName: _eventName,
        namespace: _namespace
      };
    }

    var eventParts = event.split(delimiter);
    var eventName = eventParts[0].trim().length === 0 ? null : eventParts[0];
    var namespace = eventParts[1].trim().length === 0 ? null : eventParts[1];
    return {
      eventName,
      namespace
    };
  }

}

module.exports = Emitter;
