/*!
 * @pluginjs/dom v0.7.17 (https://pluginjs.com)
 * Copyright 2019 Creation Studio Limited
 * Released under the GPL-3.0 License.
 */
import { curry, camelize, curryWith } from '@pluginjs/utils';
import { isString, isElement, isEmptyObject } from '@pluginjs/is';

var parseHTML = function parseHTML() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }

  var htmlString = Array.isArray(args[0]) ? args[0].reduce((result, str, index) => result + args[index] + str) : args[0]; // if('content' in document.createElement('template')) {
  //   const temp = document.createElement('template')
  //   temp.innerHTML = htmlString
  //   return temp.content.cloneNode(true)
  // } else {

  var el = document.createElement('div');
  el.innerHTML = htmlString;

  if (el.children.length === 1) {
    return el.children[0];
  }

  var fragment = document.createDocumentFragment();

  if (el.children.length) {
    while (el.children.length > 0) {
      fragment.appendChild(el.children[0]);
    }
  } else {
    while (el.childNodes.length > 0) {
      fragment.appendChild(el.childNodes[0]);
    }
  }

  return fragment; // }
}; // ----------
// Traversal
// ----------

var query = function query(selector) {
  var parent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : document;
  return parent.querySelector(selector);
};
var queryAll = function queryAll(selector) {
  var parent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : document;
  return Array.from(parent.querySelectorAll(selector));
};
var find = curry((selector, parent) => parent.querySelector(selector));
var findAll = curry((selector, parent) => Array.from(parent.querySelectorAll(selector)));
var has = (selector, parent) => {
  if (isString(selector)) {
    return Boolean(queryAll(selector, parent).length);
  }

  return parent.contains(selector);
};
var contents = el => {
  if (el.tagName === 'IFRAME') {
    return [el.contentDocument];
  }

  return el.childNodes;
};
var children = (selector, el) => {
  if (!isString(selector) && typeof el === 'undefined') {
    el = selector;
    selector = undefined;
  }

  if (!isElement(el)) {
    return [];
  }

  if (isString(selector)) {
    return Array.from(el.children).filter(c => c.matches(selector));
  }

  return Array.from(el.children);
};
var siblings = (selector, el) => {
  if (!isString(selector) && typeof el === 'undefined') {
    el = selector;
    selector = undefined;
  }

  if (!isElement(el)) {
    return [];
  }

  return children(selector, el.parentNode).filter(element => element !== el);
};
var prev = el => el.previousElementSibling;
var next = el => el.nextElementSibling;
var prevWith = curry((fn, el) => {
  var prevElement = el.previousElementSibling;

  if (!prevElement) {
    return null;
  }

  if (fn(prevElement)) {
    return prevElement;
  }

  return prevWith(fn, prevElement);
});
var nextWith = curry((fn, el) => {
  var nextElement = el.nextElementSibling;

  if (!nextElement) {
    return null;
  }

  if (fn(nextElement)) {
    return nextElement;
  }

  return nextWith(fn, nextElement);
});
var parent = el => el.parentNode;
var parents = (selector, el) => {
  if (!isString(selector) && typeof el === 'undefined') {
    el = selector;
    selector = undefined;
  }

  var result = [];
  var last = el;

  while (isElement(last) && last.parentNode && last !== document.body.parentNode) {
    last = last.parentNode;

    if (!selector || selector && last.matches(selector)) {
      result.push(last);
    }
  }

  return result;
};
var parentWith = curry((fn, el) => {
  var parentElement = el.parentNode;

  if (!parentElement || parentElement === document) {
    return false;
  }

  if (fn(parentElement)) {
    return parentElement;
  }

  return parentWith(fn, parentElement);
});
var closest = (selector, el) => {
  if (el.matches(selector)) {
    return el;
  }

  return parentWith(el => el.matches(selector), el);
};
var offsetParent = el => {
  var offsetParent = el.offsetParent;

  while (offsetParent && offsetParent.style.position === 'static') {
    offsetParent = offsetParent.offsetParent;
  }

  return offsetParent || document.documentElement;
};
var scrollParent = el => {
  return parentWith(parent => parent.scrollHeight > parent.clientHeight, el);
};
var indexOf = el => {
  return [...el.parentElement.children].indexOf(el);
}; // ---------
// Data
// ----------

var dataStore = '__pluginjsData';

var getCachedData = el => {
  return el[dataStore] = el[dataStore] || {};
};

var getData = (key, el) => {
  if (isElement(key) && typeof el === 'undefined') {
    el = key;
    key = undefined;
  }

  var cache = getCachedData(el);

  if (key) {
    if (!(key in cache)) {
      var value = el.dataset[key] || el.dataset[camelize(key, false)];

      if (value !== undefined) {
        try {
          value = JSON.parse(value);
        } catch (e) {} // eslint-disable-line


        cache[key] = value;
      }
    }

    return cache[key];
  }

  return cache;
};
var setData = (key, value, el) => {
  getCachedData(el)[key] = value;
  return el;
};
var removeData = (key, el) => {
  if (isElement(key) && typeof el === 'undefined') {
    el = key;
    key = undefined;
  }

  if (typeof key === 'undefined') {
    delete el[dataStore];
  } else {
    delete getCachedData(el)[key];
  }

  return el;
};
var hasData = el => {
  return dataStore in el ? !isEmptyObject(el[dataStore]) : false;
};
var data = curryWith((key, value, el) => {
  if (isElement(value) && typeof el === 'undefined') {
    el = value;
    value = undefined;
  }

  if (typeof key === 'string') {
    if (typeof value !== 'undefined') {
      setData(key, value, el);
    } else {
      return getData(key, el);
    }
  } else {
    Object.entries(key).forEach((_ref) => {
      var [k, v] = _ref;
      return setData(k, v, el);
    });
  }

  return el;
}, isElement); // -----------
// Attributes
// -----------

var attr = curryWith((args, value, el) => {
  if (isElement(value) && typeof el === 'undefined') {
    el = value;
    value = undefined;
  }

  if (typeof args === 'string') {
    if (typeof value !== 'undefined') {
      el.setAttribute(args, value);
    } else {
      return el.getAttribute(args);
    }
  } else {
    Object.entries(args).forEach((_ref2) => {
      var [key, value] = _ref2;
      return el.setAttribute(key, value);
    });
  }

  return el;
}, isElement);
var removeAttr = curry((attrs, el) => {
  attrs.split(' ').forEach(attr => {
    el.removeAttribute(attr);
  });
  return el;
});
var propMap = {
  tabindex: 'tabIndex',
  readonly: 'readOnly',
  for: 'htmlFor',
  class: 'className',
  maxlength: 'maxLength',
  cellspacing: 'cellSpacing',
  cellpadding: 'cellPadding',
  rowspan: 'rowSpan',
  colspan: 'colSpan',
  usemap: 'useMap',
  frameborder: 'frameBorder',
  contenteditable: 'contentEditable'
};
var prop = curryWith((props, value, el) => {
  if (isElement(value) && typeof el === 'undefined') {
    el = value;
    value = undefined;
  }

  if (typeof props === 'string') {
    if (typeof value !== 'undefined') {
      el[propMap[props] || props] = value;
    } else {
      return el[propMap[props] || props];
    }
  } else {
    Object.entries(props).forEach((_ref3) => {
      var [key, value] = _ref3;
      el[propMap[key] || key] = value;
    });
  }

  return el;
}, isElement);
var removeProp = curry((props, el) => {
  props.split(' ').forEach(prop => {
    prop = propMap[prop] || prop;
    delete el[prop];
  });
  return el;
}); // --------------
// Manipulation
// --------------

var clone = curry(el => el.cloneNode(true));
var detach = curry(el => {
  if (el.parentNode) {
    el.parentNode.removeChild(el);
  }

  return el;
});
var remove = curry(el => el.remove());
var empty = curry(el => {
  while (el.lastChild) {
    el.removeChild(el.lastChild);
  }

  return el;
});
var html = curryWith((content, el) => {
  if (!isString(content) && typeof el === 'undefined') {
    el = content;
    content = undefined;
  }

  if (typeof content === 'undefined') {
    return el.innerHTML;
  }

  el.innerHTML = content;
  return el;
}, isElement);
var text = curryWith((content, el) => {
  if (!isString(content) && typeof el === 'undefined') {
    el = content;
    content = undefined;
  }

  if (typeof content === 'undefined') {
    return el.textContent;
  }

  el.textContent = content;
  return el;
}, isElement);
var append = curry((child, el) => {
  if (isString(child)) {
    el.insertAdjacentHTML('beforeend', child);
  } else {
    el.append(child);
  }

  return el;
});
var appendTo = curry((child, el) => {
  if (isString(child)) {
    child = parseHTML(child);
  }

  el.append(child);
  return child;
});
var prepend = curry((child, el) => {
  if (isString(child)) {
    el.insertAdjacentHTML('afterbegin', child);
  } else {
    el.prepend(child);
  }

  return el;
});
var prependTo = curry((child, el) => {
  if (isString(child)) {
    child = parseHTML(child);
  }

  el.prepend(child);
  return child;
});
var before = curry((newElement, el) => {
  if (isString(newElement)) {
    el.insertAdjacentHTML('beforebegin', newElement);
  } else {
    el.parentNode.insertBefore(newElement, el);
  }

  return el;
});
var insertBefore = curry((newElement, el) => {
  if (isString(newElement)) {
    newElement = parseHTML(newElement);
  }

  if (NodeList.prototype.isPrototypeOf(newElement)) {
    // eslint-disable-line
    newElement.forEach(i => {
      el.parentNode.insertBefore(i, el);
    });
  } else {
    el.parentNode.insertBefore(newElement, el);
  }

  return newElement;
});
var after = curry((newElement, el) => {
  if (isString(newElement)) {
    el.insertAdjacentHTML('afterend', newElement);
  } else {
    el.parentNode.insertBefore(newElement, el.nextElementSibling);
  }

  return el;
});
var insertAfter = curry((newElement, el) => {
  if (isString(newElement)) {
    newElement = parseHTML(newElement);
  }

  if (NodeList.prototype.isPrototypeOf(newElement)) {
    // eslint-disable-line
    newElement.forEach(i => {
      el.parentNode.insertBefore(i, el.nextElementSibling);
    });
  } else {
    el.parentNode.insertBefore(newElement, el.nextElementSibling);
  }

  return newElement;
});
var wrap = curry((wrapElement, el) => {
  if (isString(wrapElement)) {
    wrapElement = parseHTML(wrapElement);
  }

  insertBefore(wrapElement, el);
  append(el, wrapElement);
  return wrapElement;
});
var wrapInner = curry((newElement, el) => {
  if (isString(newElement)) {
    newElement = parseHTML(newElement);
  }

  newElement.innerHTML = el.innerHTML;
  el.innerHTML = '';
  el.append(newElement);
  return el;
});
var wrapAll = curry((wrapElement, elementList) => {
  if (isString(wrapElement)) {
    wrapElement = parseHTML(wrapElement);
  }

  insertBefore(wrapElement, elementList[0]);
  wrapElement.append(...elementList);
  return wrapElement;
});
var unwrap = curryWith((selector, el) => {
  if (!isString(selector) && typeof el === 'undefined') {
    el = selector;
    selector = undefined;
  }

  var parentEl = el.parentNode;

  if (!selector || parentEl.matches(selector)) {
    children(parentEl).forEach(child => {
      insertBefore(child, parentEl);
    });
    parentEl.remove();
  }

  return el;
}, isElement);
var replace = curry((newContent, el) => {
  if (isString(newContent)) {
    newContent = parseHTML(newContent);
  }

  el.parentNode.replaceChild(newContent, el);
  el.remove();
  return newContent;
});

export { after, append, appendTo, attr, before, children, clone, closest, contents, data, detach, empty, find, findAll, getData, has, hasData, html, indexOf, insertAfter, insertBefore, next, nextWith, offsetParent, parent, parentWith, parents, parseHTML, prepend, prependTo, prev, prevWith, prop, query, queryAll, remove, removeAttr, removeData, removeProp, replace, scrollParent, setData, siblings, text, unwrap, wrap, wrapAll, wrapInner };
