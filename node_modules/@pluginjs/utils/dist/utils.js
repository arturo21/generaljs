/*!
 * @pluginjs/utils v0.7.16 (https://pluginjs.com)
 * Copyright 2019 Creation Studio Limited
 * Released under the GPL-3.0 License.
 */
(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@pluginjs/is')) :
  typeof define === 'function' && define.amd ? define(['exports', '@pluginjs/is'], factory) :
  (global = global || self, factory(global['@pluginjs/utils'] = {}, global['@pluginjs/is']));
}(this, function (exports, is) { 'use strict';

  function _defineProperty(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }

    return obj;
  }

  function ownKeys(object, enumerableOnly) {
    var keys = Object.keys(object);

    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      if (enumerableOnly) symbols = symbols.filter(function (sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
      keys.push.apply(keys, symbols);
    }

    return keys;
  }

  function _objectSpread2(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i] != null ? arguments[i] : {};

      if (i % 2) {
        ownKeys(source, true).forEach(function (key) {
          _defineProperty(target, key, source[key]);
        });
      } else if (Object.getOwnPropertyDescriptors) {
        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
      } else {
        ownKeys(source).forEach(function (key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
    }

    return target;
  }

  function _slicedToArray(arr, i) {
    return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest();
  }

  function _toConsumableArray(arr) {
    return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread();
  }

  function _arrayWithoutHoles(arr) {
    if (Array.isArray(arr)) {
      for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];

      return arr2;
    }
  }

  function _arrayWithHoles(arr) {
    if (Array.isArray(arr)) return arr;
  }

  function _iterableToArray(iter) {
    if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter);
  }

  function _iterableToArrayLimit(arr, i) {
    if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) {
      return;
    }

    var _arr = [];
    var _n = true;
    var _d = false;
    var _e = undefined;

    try {
      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
        _arr.push(_s.value);

        if (i && _arr.length === i) break;
      }
    } catch (err) {
      _d = true;
      _e = err;
    } finally {
      try {
        if (!_n && _i["return"] != null) _i["return"]();
      } finally {
        if (_d) throw _e;
      }
    }

    return _arr;
  }

  function _nonIterableSpread() {
    throw new TypeError("Invalid attempt to spread non-iterable instance");
  }

  function _nonIterableRest() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance");
  }

  var nub = function nub(arr) {
    return Array.from(new Set(arr));
  };
  var each = function each(obj, callback) {
    if (is.isArray(obj)) {
      var index = 0;
      var length = obj.length;

      for (; index < length; index++) {
        callback(obj[index], index);
      }
    } else {
      Object.entries(obj).map(function (_ref) {
        var _ref2 = _slicedToArray(_ref, 2),
            key = _ref2[0],
            value = _ref2[1];

        return callback(key, value);
      });
    }

    return obj;
  };
  /** to createEvent */

  function triggerNative(el, event, data) {
    var e = document.createEvent('HTMLEvents');

    if (typeof data !== 'undefined') {
      e.initCustomEvent(event, true, true, data);
    } else {
      e.initEvent(event, true, false);
    }

    el.dispatchEvent(e);
  }
  /** Credit to https://github.com/jonschlinkert/shallow-clone MIT */

  var clone = function clone(val) {
    if (is.isElement(val)) {
      return val;
    } else if (is.isArray(val)) {
      return val.slice();
    } else if (is.isDate(val)) {
      return new val.constructor(Number(val));
    } else if (is.isMap(val)) {
      return new Map(val);
    } else if (is.isSet(val)) {
      return new Set(val);
    } else if (is.isSymbol(val)) {
      return Symbol.prototype.valueOf ? Object(Symbol.prototype.valueOf.call(val)) : {};
    } else if (is.isRegexp(val)) {
      var re = new val.constructor(val.source, /\w+$/.exec(val));
      re.lastIndex = val.lastIndex;
      return re;
    } else if (is.isError(val)) {
      return Object.create(val);
    } else if (is.isPlainObject(val)) {
      return Object.assign({}, val);
    }

    return val;
  };
  /** Credit to https://github.com/jonschlinkert/clone-deep MIT */

  var deepClone = function deepClone(val) {
    if (is.isPlainObject(val)) {
      return deepCloneObject(val);
    } else if (is.isArray(val)) {
      return deepCloneArray(val);
    }

    return clone(val);
  };
  var deepCloneObject = function deepCloneObject(obj) {
    if (is.isPlainObject(obj)) {
      var res = new obj.constructor();

      for (var key in obj) {
        // eslint-disable-line
        res[key] = deepClone(obj[key]);
      }

      return res;
    }

    return obj;
  };
  var deepCloneArray = function deepCloneArray(arr) {
    var res = new arr.constructor(arr.length);

    for (var i = 0; i < arr.length; i++) {
      res[i] = deepClone(arr[i]);
    }

    return res;
  };
  var merge = function merge(target) {
    for (var _len = arguments.length, sources = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      sources[_key - 1] = arguments[_key];
    }

    sources.forEach(function (src) {
      for (var prop in src) {
        // eslint-disable-line
        target[prop] = src[prop];
      }
    });
    return target;
  };

  function deepMergeTwo(target, source) {
    var sourceIsArray = is.isArray(source);
    var targetIsArray = is.isArray(target);

    if (is.isUndefined(source)) {
      return target;
    }

    if (sourceIsArray !== targetIsArray) {
      return clone(source);
    } else if (sourceIsArray) {
      return clone(source);
    } else if (is.isPlainObject(target) && is.isPlainObject(source)) {
      Object.keys(source).forEach(function (key) {
        target[key] = deepMergeTwo(target[key], source[key]);
      });
      return target;
    }

    return clone(source);
  }

  var deepMerge = function deepMerge() {
    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }

    return args.filter(is.isObject).reduce(deepMergeTwo, {});
  };
  var curry = function curry(fn) {
    var args = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
    return function () {
      var currylen = fn.currylen || fn.length;

      for (var _len3 = arguments.length, subArgs = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
        subArgs[_key3] = arguments[_key3];
      }

      var collect = args.concat(subArgs);

      if (collect.length >= currylen) {
        return fn.apply(void 0, _toConsumableArray(collect));
      }

      return curry(fn, collect);
    };
  };
  var curryWith = function curryWith(fn, enSureFunction) {
    var args = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];
    return function () {
      for (var _len4 = arguments.length, subArgs = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
        subArgs[_key4] = arguments[_key4];
      }

      var index = subArgs.findIndex(enSureFunction);

      if (index >= 0) {
        var _collect = args.concat.apply(args, _toConsumableArray(subArgs.slice(0, index + 1)));

        return fn.apply(void 0, _toConsumableArray(_collect));
      }

      var collect = args.concat.apply(args, subArgs);
      return curryWith(fn, enSureFunction, collect);
    };
  };
  var compose = function compose() {
    for (var _len5 = arguments.length, fn = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
      fn[_key5] = arguments[_key5];
    }

    var callback = function callback() {
      for (var _len6 = arguments.length, args = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {
        args[_key6] = arguments[_key6];
      }

      return fn.reduceRight(function (r, i, index) {
        if (Array.isArray(r) && index === fn.length - 1) {
          return i.apply(void 0, _toConsumableArray(r));
        }

        return i(r);
      }, args);
    };

    callback.currylen = fn[fn.curylen || fn.length - 1].length;
    return callback;
  };
  var MAX_UID = 1000000;
  var getUID = function getUID(prefix) {
    do {
      // eslint-disable-next-line no-bitwise
      prefix += ~~(Math.random() * MAX_UID); // "~~" acts like a faster Math.floor() here
    } while (document.getElementById(prefix));

    return prefix;
  };
  var range = function range(v) {
    return Array.from({
      length: v
    }, function (v, i) {
      return i;
    });
  };
  var reflow = function reflow(element) {
    return element.offsetHeight;
  };
  var arrayEqual = function arrayEqual(a, b) {
    if (a === b) {
      return true;
    }

    if (typeof a === 'undefined' || typeof b === 'undefined') {
      return false;
    }

    if (a.length !== b.length) {
      return false;
    }

    for (var i = 0; i < a.length; ++i) {
      if (a[i] !== b[i]) {
        return false;
      }
    }

    return true;
  };
  var objectEqual = function objectEqual(a, b) {
    var aProps = Object.getOwnPropertyNames(a);
    var bProps = Object.getOwnPropertyNames(b);

    if (aProps.length !== bProps.length) {
      return false;
    }

    for (var i = 0; i < aProps.length; i++) {
      var prop = aProps[i];

      if (is.isArray(a[prop]) && is.isArray(b[prop])) {
        if (!arrayEqual(a[prop], b[prop])) {
          return false;
        }
      } else if (is.isObject(a[prop]) && is.isObject(b[prop])) {
        if (!objectEqual(a[prop], b[prop])) {
          return false;
        }
      } else if (a[prop] !== b[prop]) {
        return false;
      }
    }

    return true;
  };
  var arrayDiff = function arrayDiff(a, b) {
    return a.filter(function (n) {
      return b.indexOf(n) < 0;
    });
  };
  var arrayIntersect = function arrayIntersect(a, b) {
    var t;

    if (b.length > a.length) {
      t = b;
      b = a;
      a = t;
    }

    return a.filter(function (n) {
      return b.indexOf(n) !== -1;
    });
  };
  var convertPercentageToFloat = function convertPercentageToFloat(n) {
    return parseFloat(n.slice(0, -1) / 100, 10);
  };
  var convertFloatToPercentage = function convertFloatToPercentage(n) {
    if (n < 0) {
      n = 0;
    } else if (n > 1) {
      n = 1;
    }

    return "".concat(parseFloat(n).toFixed(4) * 100, "%");
  };
  var convertMatrixToArray = function convertMatrixToArray(value) {
    if (value && value.substr(0, 6) === 'matrix') {
      return value.replace(/^.*\((.*)\)$/g, '$1').replace(/px/g, '').split(/, +/);
    }

    return false;
  };
  var getTime = function getTime() {
    if (typeof window.performance !== 'undefined' && window.performance.now) {
      return window.performance.now();
    }

    return Date.now();
  };
  var camelize = function camelize(word) {
    var first = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
    word = word.replace(/[_.\- ]+(\w|$)/g, function (m, p1) {
      return p1.toUpperCase();
    });

    if (first) {
      word = word.substring(0, 1).toUpperCase() + word.substring(1);
    }

    return word;
  };
  var dasherize = function dasherize(word) {
    return word.replace(/([a-z\d])([A-Z])/g, '$1-$2').toLowerCase();
  };
  /* Credit to https://github.com/jonschlinkert/get-value MIT */

  var getValueByPath = function getValueByPath(obj, path) {
    if (Object(obj) !== obj || typeof path === 'undefined') {
      return obj;
    }

    if (path in obj) {
      return obj[path];
    }

    var segs = path.split('.');
    var length = segs.length;

    if (!length) {
      return undefined;
    }

    var i = -1;

    while (obj && ++i < length) {
      var key = segs[i];

      while (key[key.length - 1] === '\\') {
        key = "".concat(key.slice(0, -1), ".").concat(segs[++i]);
      }

      obj = obj[key];
    }

    return obj;
  };
  /* Throttle execution of a function.
   * Especially useful for rate limiting execution of
   * handlers on events like resize and scroll. */

  function throttle(func, delay) {
    var _this = this;

    var running = false;

    function resetRunning() {
      running = false;
    }

    if (typeof delay !== 'undefined' || delay !== null) {
      return function () {
        var that = _this;

        if (running) {
          return;
        }

        running = true;

        for (var _len7 = arguments.length, args = new Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {
          args[_key7] = arguments[_key7];
        }

        func.apply(that, args);
        window.setTimeout(resetRunning, delay);
      };
    }

    return function () {
      for (var _len8 = arguments.length, args = new Array(_len8), _key8 = 0; _key8 < _len8; _key8++) {
        args[_key8] = arguments[_key8];
      }

      var that = _this;

      if (running) {
        return;
      }

      running = true;
      window.requestAnimationFrame(function () {
        func.apply(that, args);
        resetRunning();
      });
    };
  }
  /* Debounce execution of a function.
   * Debouncing, unlike throttling, guarantees that a function
   * is only executed a single time at the very end. */

  function debounce(func) {
    var _this2 = this;

    var delay = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 100;
    var timer;
    return function () {
      for (var _len9 = arguments.length, args = new Array(_len9), _key9 = 0; _key9 < _len9; _key9++) {
        args[_key9] = arguments[_key9];
      }

      var that = _this2;

      if (timer) {
        clearTimeout(timer);
        timer = null;
      }

      timer = setTimeout(function () {
        func.apply(that, args);
      }, delay);
    };
  }
  function fromPairs(arr) {
    return arr.reduce(function (r, _ref3) {
      var _ref4 = _slicedToArray(_ref3, 2),
          k = _ref4[0],
          v = _ref4[1];

      return _objectSpread2({}, r, _defineProperty({}, k, v));
    }, {});
  }
  var SvgElement = function SvgElement(tag, attrs) {
    var el = document.createElementNS('http://www.w3.org/2000/svg', tag);

    if (!attrs) {
      return el;
    }

    for (var key in attrs) {
      if (!Object.hasOwnProperty.call(attrs, key)) {
        continue;
      }

      el.setAttribute(key, attrs[key]);
    }

    return el;
  };
  function parseDataOptions(dataset) {
    return Object.entries(dataset).reduce(function (result, _ref5) {
      var _ref6 = _slicedToArray(_ref5, 2),
          k = _ref6[0],
          v = _ref6[1];

      try {
        var content = JSON.parse("{\"data\": ".concat(v.replace(/'/g, '"'), "}")).data;
        return _objectSpread2({}, result, _defineProperty({}, k, content));
      } catch (err) {
        return _objectSpread2({}, result, _defineProperty({}, k, v));
      }
    }, {});
  }

  exports.SvgElement = SvgElement;
  exports.arrayDiff = arrayDiff;
  exports.arrayEqual = arrayEqual;
  exports.arrayIntersect = arrayIntersect;
  exports.camelize = camelize;
  exports.clone = clone;
  exports.compose = compose;
  exports.convertFloatToPercentage = convertFloatToPercentage;
  exports.convertMatrixToArray = convertMatrixToArray;
  exports.convertPercentageToFloat = convertPercentageToFloat;
  exports.curry = curry;
  exports.curryWith = curryWith;
  exports.dasherize = dasherize;
  exports.debounce = debounce;
  exports.deepClone = deepClone;
  exports.deepCloneArray = deepCloneArray;
  exports.deepCloneObject = deepCloneObject;
  exports.deepMerge = deepMerge;
  exports.each = each;
  exports.fromPairs = fromPairs;
  exports.getTime = getTime;
  exports.getUID = getUID;
  exports.getValueByPath = getValueByPath;
  exports.merge = merge;
  exports.nub = nub;
  exports.objectEqual = objectEqual;
  exports.parseDataOptions = parseDataOptions;
  exports.range = range;
  exports.reflow = reflow;
  exports.throttle = throttle;
  exports.triggerNative = triggerNative;

  Object.defineProperty(exports, '__esModule', { value: true });

}));
