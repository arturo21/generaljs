/*!
 * @pluginjs/utils v0.7.16 (https://pluginjs.com)
 * Copyright 2019 Creation Studio Limited
 * Released under the GPL-3.0 License.
 */
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var is = require('@pluginjs/is');

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    });
    keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread2(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};

    if (i % 2) {
      ownKeys(source, true).forEach(function (key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys(source).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }

  return target;
}

var nub = arr => {
  return Array.from(new Set(arr));
};
var each = (obj, callback) => {
  if (is.isArray(obj)) {
    var index = 0;
    var length = obj.length;

    for (; index < length; index++) {
      callback(obj[index], index);
    }
  } else {
    Object.entries(obj).map((_ref) => {
      var [key, value] = _ref;
      return callback(key, value);
    });
  }

  return obj;
};
/** to createEvent */

function triggerNative(el, event, data) {
  var e = document.createEvent('HTMLEvents');

  if (typeof data !== 'undefined') {
    e.initCustomEvent(event, true, true, data);
  } else {
    e.initEvent(event, true, false);
  }

  el.dispatchEvent(e);
}
/** Credit to https://github.com/jonschlinkert/shallow-clone MIT */

var clone = val => {
  if (is.isElement(val)) {
    return val;
  } else if (is.isArray(val)) {
    return val.slice();
  } else if (is.isDate(val)) {
    return new val.constructor(Number(val));
  } else if (is.isMap(val)) {
    return new Map(val);
  } else if (is.isSet(val)) {
    return new Set(val);
  } else if (is.isSymbol(val)) {
    return Symbol.prototype.valueOf ? Object(Symbol.prototype.valueOf.call(val)) : {};
  } else if (is.isRegexp(val)) {
    var re = new val.constructor(val.source, /\w+$/.exec(val));
    re.lastIndex = val.lastIndex;
    return re;
  } else if (is.isError(val)) {
    return Object.create(val);
  } else if (is.isPlainObject(val)) {
    return Object.assign({}, val);
  }

  return val;
};
/** Credit to https://github.com/jonschlinkert/clone-deep MIT */

var deepClone = val => {
  if (is.isPlainObject(val)) {
    return deepCloneObject(val);
  } else if (is.isArray(val)) {
    return deepCloneArray(val);
  }

  return clone(val);
};
var deepCloneObject = obj => {
  if (is.isPlainObject(obj)) {
    var res = new obj.constructor();

    for (var key in obj) {
      // eslint-disable-line
      res[key] = deepClone(obj[key]);
    }

    return res;
  }

  return obj;
};
var deepCloneArray = arr => {
  var res = new arr.constructor(arr.length);

  for (var i = 0; i < arr.length; i++) {
    res[i] = deepClone(arr[i]);
  }

  return res;
};
var merge = function merge(target) {
  for (var _len = arguments.length, sources = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    sources[_key - 1] = arguments[_key];
  }

  sources.forEach(src => {
    for (var prop in src) {
      // eslint-disable-line
      target[prop] = src[prop];
    }
  });
  return target;
};

function deepMergeTwo(target, source) {
  var sourceIsArray = is.isArray(source);
  var targetIsArray = is.isArray(target);

  if (is.isUndefined(source)) {
    return target;
  }

  if (sourceIsArray !== targetIsArray) {
    return clone(source);
  } else if (sourceIsArray) {
    return clone(source);
  } else if (is.isPlainObject(target) && is.isPlainObject(source)) {
    Object.keys(source).forEach(key => {
      target[key] = deepMergeTwo(target[key], source[key]);
    });
    return target;
  }

  return clone(source);
}

var deepMerge = function deepMerge() {
  for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
    args[_key2] = arguments[_key2];
  }

  return args.filter(is.isObject).reduce(deepMergeTwo, {});
};
var curry = function curry(fn) {
  var args = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
  return function () {
    var currylen = fn.currylen || fn.length;

    for (var _len3 = arguments.length, subArgs = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
      subArgs[_key3] = arguments[_key3];
    }

    var collect = args.concat(subArgs);

    if (collect.length >= currylen) {
      return fn(...collect);
    }

    return curry(fn, collect);
  };
};
var curryWith = function curryWith(fn, enSureFunction) {
  var args = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];
  return function () {
    for (var _len4 = arguments.length, subArgs = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
      subArgs[_key4] = arguments[_key4];
    }

    var index = subArgs.findIndex(enSureFunction);

    if (index >= 0) {
      var _collect = args.concat(...subArgs.slice(0, index + 1));

      return fn(..._collect);
    }

    var collect = args.concat(...subArgs);
    return curryWith(fn, enSureFunction, collect);
  };
};
var compose = function compose() {
  for (var _len5 = arguments.length, fn = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
    fn[_key5] = arguments[_key5];
  }

  var callback = function callback() {
    for (var _len6 = arguments.length, args = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {
      args[_key6] = arguments[_key6];
    }

    return fn.reduceRight((r, i, index) => {
      if (Array.isArray(r) && index === fn.length - 1) {
        return i(...r);
      }

      return i(r);
    }, args);
  };

  callback.currylen = fn[fn.curylen || fn.length - 1].length;
  return callback;
};
var MAX_UID = 1000000;
var getUID = prefix => {
  do {
    // eslint-disable-next-line no-bitwise
    prefix += ~~(Math.random() * MAX_UID); // "~~" acts like a faster Math.floor() here
  } while (document.getElementById(prefix));

  return prefix;
};
var range = v => Array.from({
  length: v
}, (v, i) => i);
var reflow = element => element.offsetHeight;
var arrayEqual = (a, b) => {
  if (a === b) {
    return true;
  }

  if (typeof a === 'undefined' || typeof b === 'undefined') {
    return false;
  }

  if (a.length !== b.length) {
    return false;
  }

  for (var i = 0; i < a.length; ++i) {
    if (a[i] !== b[i]) {
      return false;
    }
  }

  return true;
};
var objectEqual = (a, b) => {
  var aProps = Object.getOwnPropertyNames(a);
  var bProps = Object.getOwnPropertyNames(b);

  if (aProps.length !== bProps.length) {
    return false;
  }

  for (var i = 0; i < aProps.length; i++) {
    var prop = aProps[i];

    if (is.isArray(a[prop]) && is.isArray(b[prop])) {
      if (!arrayEqual(a[prop], b[prop])) {
        return false;
      }
    } else if (is.isObject(a[prop]) && is.isObject(b[prop])) {
      if (!objectEqual(a[prop], b[prop])) {
        return false;
      }
    } else if (a[prop] !== b[prop]) {
      return false;
    }
  }

  return true;
};
var arrayDiff = (a, b) => {
  return a.filter(n => b.indexOf(n) < 0);
};
var arrayIntersect = (a, b) => {
  var t;

  if (b.length > a.length) {
    t = b;
    b = a;
    a = t;
  }

  return a.filter(n => b.indexOf(n) !== -1);
};
var convertPercentageToFloat = n => parseFloat(n.slice(0, -1) / 100, 10);
var convertFloatToPercentage = n => {
  if (n < 0) {
    n = 0;
  } else if (n > 1) {
    n = 1;
  }

  return "".concat(parseFloat(n).toFixed(4) * 100, "%");
};
var convertMatrixToArray = value => {
  if (value && value.substr(0, 6) === 'matrix') {
    return value.replace(/^.*\((.*)\)$/g, '$1').replace(/px/g, '').split(/, +/);
  }

  return false;
};
var getTime = () => {
  if (typeof window.performance !== 'undefined' && window.performance.now) {
    return window.performance.now();
  }

  return Date.now();
};
var camelize = function camelize(word) {
  var first = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
  word = word.replace(/[_.\- ]+(\w|$)/g, (m, p1) => p1.toUpperCase());

  if (first) {
    word = word.substring(0, 1).toUpperCase() + word.substring(1);
  }

  return word;
};
var dasherize = word => word.replace(/([a-z\d])([A-Z])/g, '$1-$2').toLowerCase();
/* Credit to https://github.com/jonschlinkert/get-value MIT */

var getValueByPath = (obj, path) => {
  if (Object(obj) !== obj || typeof path === 'undefined') {
    return obj;
  }

  if (path in obj) {
    return obj[path];
  }

  var segs = path.split('.');
  var length = segs.length;

  if (!length) {
    return undefined;
  }

  var i = -1;

  while (obj && ++i < length) {
    var key = segs[i];

    while (key[key.length - 1] === '\\') {
      key = "".concat(key.slice(0, -1), ".").concat(segs[++i]);
    }

    obj = obj[key];
  }

  return obj;
};
/* Throttle execution of a function.
 * Especially useful for rate limiting execution of
 * handlers on events like resize and scroll. */

function throttle(func, delay) {
  var _this = this;

  var running = false;

  function resetRunning() {
    running = false;
  }

  if (typeof delay !== 'undefined' || delay !== null) {
    return function () {
      var that = _this;

      if (running) {
        return;
      }

      running = true;

      for (var _len7 = arguments.length, args = new Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {
        args[_key7] = arguments[_key7];
      }

      func.apply(that, args);
      window.setTimeout(resetRunning, delay);
    };
  }

  return function () {
    for (var _len8 = arguments.length, args = new Array(_len8), _key8 = 0; _key8 < _len8; _key8++) {
      args[_key8] = arguments[_key8];
    }

    var that = _this;

    if (running) {
      return;
    }

    running = true;
    window.requestAnimationFrame(() => {
      func.apply(that, args);
      resetRunning();
    });
  };
}
/* Debounce execution of a function.
 * Debouncing, unlike throttling, guarantees that a function
 * is only executed a single time at the very end. */

function debounce(func) {
  var _this2 = this;

  var delay = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 100;
  var timer;
  return function () {
    for (var _len9 = arguments.length, args = new Array(_len9), _key9 = 0; _key9 < _len9; _key9++) {
      args[_key9] = arguments[_key9];
    }

    var that = _this2;

    if (timer) {
      clearTimeout(timer);
      timer = null;
    }

    timer = setTimeout(() => {
      func.apply(that, args);
    }, delay);
  };
}
function fromPairs(arr) {
  return arr.reduce((r, _ref2) => {
    var [k, v] = _ref2;
    return _objectSpread2({}, r, {
      [k]: v
    });
  }, {});
}
var SvgElement = (tag, attrs) => {
  var el = document.createElementNS('http://www.w3.org/2000/svg', tag);

  if (!attrs) {
    return el;
  }

  for (var key in attrs) {
    if (!Object.hasOwnProperty.call(attrs, key)) {
      continue;
    }

    el.setAttribute(key, attrs[key]);
  }

  return el;
};
function parseDataOptions(dataset) {
  return Object.entries(dataset).reduce((result, _ref3) => {
    var [k, v] = _ref3;

    try {
      var content = JSON.parse("{\"data\": ".concat(v.replace(/'/g, '"'), "}")).data;
      return _objectSpread2({}, result, {
        [k]: content
      });
    } catch (err) {
      return _objectSpread2({}, result, {
        [k]: v
      });
    }
  }, {});
}

exports.SvgElement = SvgElement;
exports.arrayDiff = arrayDiff;
exports.arrayEqual = arrayEqual;
exports.arrayIntersect = arrayIntersect;
exports.camelize = camelize;
exports.clone = clone;
exports.compose = compose;
exports.convertFloatToPercentage = convertFloatToPercentage;
exports.convertMatrixToArray = convertMatrixToArray;
exports.convertPercentageToFloat = convertPercentageToFloat;
exports.curry = curry;
exports.curryWith = curryWith;
exports.dasherize = dasherize;
exports.debounce = debounce;
exports.deepClone = deepClone;
exports.deepCloneArray = deepCloneArray;
exports.deepCloneObject = deepCloneObject;
exports.deepMerge = deepMerge;
exports.each = each;
exports.fromPairs = fromPairs;
exports.getTime = getTime;
exports.getUID = getUID;
exports.getValueByPath = getValueByPath;
exports.merge = merge;
exports.nub = nub;
exports.objectEqual = objectEqual;
exports.parseDataOptions = parseDataOptions;
exports.range = range;
exports.reflow = reflow;
exports.throttle = throttle;
exports.triggerNative = triggerNative;
